import JSZip from 'jszip';
import saveAs from 'file-saver';

export type ProcessStage = 'idle' | 'reading' | 'analyzing' | 'patching' | 'compressing' | 'done' | 'error';

interface ProcessOptions {
  onProgress: (stage: ProcessStage, message?: string) => void;
}

/**
 * Checks if a string is an absolute path (starts with /) but not a protocol link (//, http://)
 */
const isAbsolutePath = (path: string) => {
  return path.startsWith('/') && !path.startsWith('//');
};

/**
 * Replaces absolute paths in HTML content with relative paths.
 * Targets: src, href, srcset, poster, action, data
 */
const fixHtmlContent = (html: string): string => {
  // Regex explanation:
  // (src|href|...)=  -> Match attribute name
  // (["'])           -> Match opening quote (capture group 2)
  // \/(?!\/)         -> Match starting slash, BUT ensure it's not followed by another slash (protocol relative)
  // ([^"']+)         -> Match the path content (capture group 3)
  // \2               -> Match matching closing quote
  
  return html.replace(
    /(src|href|srcset|poster|action|data|content)=(['"])\/(?!\/)([^'"]+)\2/gi,
    (match, attr, quote, path) => {
      // Don't touch if it looks like a variable or data URI (though regex handles most)
      return `${attr}=${quote}./${path}${quote}`;
    }
  );
};

/**
 * Replaces absolute paths in CSS content.
 * Targets: url(/path/to/asset)
 */
const fixCssContent = (css: string): string => {
  return css.replace(/url\(['"]?\/([^'"\)]+)['"]?\)/gi, 'url("./$1")');
};

/**
 * Parses and fixes manifest.json/webmanifest paths.
 */
const fixManifest = (content: string): string => {
  try {
    const json = JSON.parse(content);
    
    // Fix start_url
    if (json.start_url && isAbsolutePath(json.start_url)) {
      json.start_url = '.' + json.start_url;
    } else if (json.start_url === '/') {
      json.start_url = './index.html';
    }

    // Fix scope
    if (json.scope && isAbsolutePath(json.scope)) {
      json.scope = './';
    }

    // Fix icons
    if (Array.isArray(json.icons)) {
      json.icons = json.icons.map((icon: any) => {
        if (icon.src && isAbsolutePath(icon.src)) {
          return { ...icon, src: '.' + icon.src };
        }
        return icon;
      });
    }

    // Fix screenshots
    if (Array.isArray(json.screenshots)) {
      json.screenshots = json.screenshots.map((shot: any) => {
        if (shot.src && isAbsolutePath(shot.src)) {
          return { ...shot, src: '.' + shot.src };
        }
        return shot;
      });
    }

    return JSON.stringify(json, null, 2);
  } catch (e) {
    console.warn('Manifest parse error, returning original', e);
    return content;
  }
};

/**
 * Generates a basic vite.config.js to ensure 'base' is handled if user runs dev locally
 */
const generateViteConfig = () => {
  return `import { defineConfig } from 'vite';
// Auto-generated by AI Studio Exporter
export default defineConfig({
  base: './', // Ensures relative paths for static deployment
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
  }
});`;
};

/**
 * Generates _redirects for SPA routing on Netlify/Cloudflare
 */
const generateRedirects = () => {
  return `/*  /index.html  200`;
};

export const processZip = async (file: File, options: ProcessOptions) => {
  const { onProgress } = options;

  try {
    onProgress('reading', 'Loading ZIP file...');
    const zip = new JSZip();
    const loadedZip = await zip.loadAsync(file);
    const newZip = new JSZip();

    // 1. Analyze structure: Check if everything is inside a single root folder
    onProgress('analyzing', 'Analyzing project structure...');
    const files = Object.keys(loadedZip.files);
    const rootDir = files.find(f => f.endsWith('/') && files.every(other => other.startsWith(f)));
    
    // 2. Process files
    const filePromises: Promise<void>[] = [];

    loadedZip.forEach((relativePath, zipEntry) => {
      const promise = (async () => {
        if (zipEntry.dir) return;

        // If flattened, strip the root dir from path
        let targetPath = relativePath;
        if (rootDir && relativePath.startsWith(rootDir)) {
          targetPath = relativePath.substring(rootDir.length);
        }

        const lowerName = targetPath.toLowerCase();

        // -- LOGIC: HTML Files --
        if (lowerName.endsWith('.html')) {
          onProgress('patching', `Fixing paths in ${targetPath}...`);
          let content = await zipEntry.async('string');
          content = fixHtmlContent(content);
          newZip.file(targetPath, content);
        } 
        // -- LOGIC: CSS Files --
        else if (lowerName.endsWith('.css')) {
          let content = await zipEntry.async('string');
          content = fixCssContent(content);
          newZip.file(targetPath, content);
        }
        // -- LOGIC: Manifest --
        else if (lowerName.endsWith('manifest.json') || lowerName.endsWith('.webmanifest')) {
          onProgress('patching', `Optimizing PWA Manifest...`);
          let content = await zipEntry.async('string');
          content = fixManifest(content);
          newZip.file(targetPath, content);
        }
        // -- LOGIC: Pass through binaries --
        else {
          const blob = await zipEntry.async('blob');
          newZip.file(targetPath, blob);
        }
      })();
      filePromises.push(promise);
    });

    await Promise.all(filePromises);

    // 3. Inject Helper Files
    onProgress('patching', 'Injecting deployment configs...');
    if (!newZip.file('vite.config.js') && !newZip.file('vite.config.ts')) {
      newZip.file('vite.config.js', generateViteConfig());
    }
    // Add _redirects for SPA fallback (useful for Cloudflare/Netlify)
    newZip.file('_redirects', generateRedirects());

    // 4. Compress
    onProgress('compressing', 'Packaging optimized ZIP...');
    const content = await newZip.generateAsync({ type: 'blob' });
    
    const originalName = file.name.replace(/\.zip$/i, '');
    const timestamp = new Date().toISOString().slice(0, 10);
    const newFilename = `${originalName}_deploy_ready_${timestamp}.zip`;

    saveAs(content, newFilename);
    onProgress('done', 'Download started!');

  } catch (err) {
    console.error('ZIP Process Error:', err);
    onProgress('error', 'Failed to process ZIP. See console.');
  }
};